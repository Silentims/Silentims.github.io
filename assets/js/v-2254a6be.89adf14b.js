"use strict";(self.webpackChunkswbook=self.webpackChunkswbook||[]).push([[173],{8430:(e,n,i)=>{i.r(n),i.d(n,{data:()=>r});const r={key:"v-2254a6be",path:"/interview/java-synchronized.html",title:"大厂之——Synchronized锁",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"Synchronized可以作用在哪里?",slug:"synchronized可以作用在哪里",children:[]},{level:2,title:"Synchronized本质上是通过什么保证线程安全的?",slug:"synchronized本质上是通过什么保证线程安全的",children:[]},{level:2,title:"拓展：JVM锁的优化",slug:"拓展-jvm锁的优化",children:[]},{level:2,title:"拓展：锁类型",slug:"拓展-锁类型",children:[]},{level:2,title:"Synchronized有什么样的缺陷?  Java Lock是怎么弥补这些缺陷的。",slug:"synchronized有什么样的缺陷-java-lock是怎么弥补这些缺陷的。",children:[]},{level:2,title:"Synchronized在使用时有何注意事项?",slug:"synchronized在使用时有何注意事项",children:[]},{level:2,title:"Synchronized修饰的方法在抛出异常时,会释放锁吗?",slug:"synchronized修饰的方法在抛出异常时-会释放锁吗",children:[]},{level:2,title:"多个线程等待同一个snchronized锁的时候，JVM如何选择下一个获取锁的线程?",slug:"多个线程等待同一个snchronized锁的时候-jvm如何选择下一个获取锁的线程",children:[]},{level:2,title:"Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?",slug:"synchronized使得同时只有一个线程可以执行-性能比较差-有什么提升的方法",children:[]},{level:2,title:"我想更加灵活地控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办?",slug:"我想更加灵活地控制锁的释放和获取-现在释放锁和获取锁的时机都被规定死了-怎么办",children:[]},{level:2,title:"什么是锁的升级和降级? 什么是JVM里的偏斜锁、轻量级锁、重量级锁?",slug:"什么是锁的升级和降级-什么是jvm里的偏斜锁、轻量级锁、重量级锁",children:[]},{level:2,title:"不同的JDK中对Synchronized有何优化?",slug:"不同的jdk中对synchronized有何优化",children:[]}],filePathRelative:"interview/java-synchronized.md"}},3482:(e,n,i)=>{i.r(n),i.d(n,{default:()=>h});const r=(0,i(6252).uE)('<h1 id="大厂之——synchronized锁" tabindex="-1"><a class="header-anchor" href="#大厂之——synchronized锁" aria-hidden="true">#</a> 大厂之——Synchronized锁</h1><ul><li>Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例。</li><li>Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。</li><li>Synchronized由什么样的缺陷? Java Lock是怎么弥补这些缺陷的。</li><li>Synchronized和Lock的对比，和选择?</li><li>Synchronized在使用时有何注意事项?</li><li>Synchronized修饰的方法在抛出异常时,会释放锁吗?</li><li>多个线程等待同一个snchronized锁的时候，JVM如何选择下一个获取锁的线程?</li><li>Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?</li><li>我想更加灵活地控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办?</li><li>什么是锁的升级和降级? 什么是JVM里的偏斜锁、轻量级锁、重量级锁?</li><li>不同的JDK中对Synchronized有何优化?</li></ul><h2 id="synchronized可以作用在哪里" tabindex="-1"><a class="header-anchor" href="#synchronized可以作用在哪里" aria-hidden="true">#</a> Synchronized可以作用在哪里?</h2><blockquote><p>分别通过对象锁和类锁进行举例。</p></blockquote><p>可以作用在两个地方，一个是方法上，一个是代码块上</p><p>但是锁的具体，可以是对象，也可以是类。</p><p>所以存在三种使用方式：</p><p>定义在普通方法上，锁的是对象。</p><p>定义在static的方法上，锁的是类（因为static修饰的方法为静态方法，在JVM启动运行后只有一份，属于类）</p><p>而代码块中允许定义this或者类.class，则根据不同的定义，锁的可以是对象，也可以是类</p><p>**总结：作用在两个地方，共三种使用方式。</p><h2 id="synchronized本质上是通过什么保证线程安全的" tabindex="-1"><a class="header-anchor" href="#synchronized本质上是通过什么保证线程安全的" aria-hidden="true">#</a> Synchronized本质上是通过什么保证线程安全的?</h2><blockquote><p>分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。</p></blockquote><p><strong>加锁原理：</strong></p><p>通过monitorenter指令或ACC_SYNCHRONIZED，编译时期会在Synchronized修饰的代码块或方法插入，首先获取锁前必须获取monitor监控器对象，若加锁成功，则锁计数器+1，如果没获取到则线程进入blocked状态，同时在队列中等待锁释放。</p><p><strong>释放锁的原理：</strong></p><p>monitorexit指令，释放对于monitor的所有权，与加锁相反，释放锁成功则锁计数器-1，直到为0，则代表当前线程不再拥有该monitor的所有权，即释放锁。</p><p><strong>可重入原理：</strong></p><p>每个对象都有加锁次数计数器，支持可重入，对于重入时无需再次获得锁，直接计数器+1即可，释放锁-1即可</p><p><strong>保证可见性原理：</strong></p><p>happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before等于对该监视器的加锁。</p><p>eg：A happens-before B ，表示A的执行结果对B可见，并且A的顺序先于B</p><p>**总结：加锁计数器+1、解锁计数器-1、可重入无需再次获得锁、A happens-before B 保证A的结果对B可见 **</p><p>关键词：锁计数器、可重入、监视器锁规则(happens-before)</p><h2 id="拓展-jvm锁的优化" tabindex="-1"><a class="header-anchor" href="#拓展-jvm锁的优化" aria-hidden="true">#</a> 拓展：JVM锁的优化</h2><ul><li>为什么要优化？</li></ul><p>monitorenter和monitorexit依赖底层操作系统的Mutex Lock实现，该实现需要线程挂起和从用户态切换到内核态执行，切换开销大</p><ul><li>优化的方法都有哪些？</li></ul><p>锁粗化：将多个连续的锁扩展成一个范围更大的锁。</p><p>锁消除：运行时JIT编译器的逃逸分析来消除同步块之外的共享数据锁保护</p><p>偏向锁：为了无锁竞争的情况下，避免在锁获取过程中执行不必要的CAS原子指令</p><p>轻量级锁：基于假设</p><p>适应性自旋：当线程在获取轻量级锁的过程中执行CAS操作失败时，让没有获取到锁的线程在门外等待一会(自旋)，但不放弃CPU的执行时间。等待持有锁的线程是否很快就会释放锁。</p><p><strong>总结：</strong></p><h2 id="拓展-锁类型" tabindex="-1"><a class="header-anchor" href="#拓展-锁类型" aria-hidden="true">#</a> 拓展：锁类型</h2><ul><li><p>自旋锁：jdk1.4就有，默认关闭，jdk6后默认开启，简单说，让另一个没有获取到锁的线程在门外等待一会(自旋)，这个与阻塞概念不同，因为自旋时仍然占用CPU时间片，控制好自旋的时间对性能有很大提升，默认自旋次数为10次，</p><p>【等待过程自旋，但是自旋次数固定，可能存在处理器资源浪费问题】</p></li><li><p>适应性自旋：自旋锁不够聪明，只能按配置的默默自旋，比如自旋刚结束就释放了锁，得不偿失，所以jdk6引入适应性自旋，即自旋的时间不再固定，JVM会依据前一次在同一个锁上自旋的时间和最终自旋后获取锁的成功率来决定，对于自旋后获取锁的可能性很大的会增加等待时间，对于那些可能性小的则略过自旋过程，避免浪费处理器资源</p><p>【更聪明的自旋锁，依据上一次自旋时间和获取锁的成功率判断，延长自旋，和略过概率低的自旋，避免浪费】</p></li><li><p>锁消除：即时编译器在运行时，判断同步代码中的数据是否涉及逃逸来进行对锁的消除，具体判断依据就是对代码中那些明显不会被其他线程访问到的，此时JVM就把这样的当做栈上数据来对待，认为这些数据是线程独有的，不需要加同步，此时就会进行锁消除。虽然在实际开发中我们清楚哪些是线程独有的不需要加锁，但是Java API中很多地方都用到了同步，所以JVM就会判断到底要不要真正的加锁，比如对String字符串的拼接，由于String本身是不可变的，所以会做自动优化，</p><p>【即时编译器JIT，运行过程中，检查同步代码中数据是否涉及逃逸，不涉及，默认为栈上操作，即线程私有，直接消除锁】</p></li><li></li></ul><h2 id="synchronized有什么样的缺陷-java-lock是怎么弥补这些缺陷的。" tabindex="-1"><a class="header-anchor" href="#synchronized有什么样的缺陷-java-lock是怎么弥补这些缺陷的。" aria-hidden="true">#</a> Synchronized有什么样的缺陷? Java Lock是怎么弥补这些缺陷的。</h2><ul><li>效率低：释放情况少，只有代码执行完或者异常才能释放，还不能设置超时，Lock可以中断和设置超时时间</li><li>不够灵活：每个锁仅有一个单一的条件；Lock包括读写锁，更加灵活</li><li>无法知道是否成功获得锁：因为是JVM级别的锁；Lock有方法可以获取锁的状态</li></ul><h2 id="synchronized在使用时有何注意事项" tabindex="-1"><a class="header-anchor" href="#synchronized在使用时有何注意事项" aria-hidden="true">#</a> Synchronized在使用时有何注意事项?</h2><ul><li>锁对象不能为空（因为锁信息都保存在对象头中）</li><li>作用域不宜过大，影响程序执行的速度，范围越大，编写代码也容易出错</li><li>避免死锁</li><li>在能选择下的情况，尽量不要用Lock和synchronized，用java.util.concurrent包中的各种各样的类</li></ul><h2 id="synchronized修饰的方法在抛出异常时-会释放锁吗" tabindex="-1"><a class="header-anchor" href="#synchronized修饰的方法在抛出异常时-会释放锁吗" aria-hidden="true">#</a> Synchronized修饰的方法在抛出异常时,会释放锁吗?</h2><p>会释放；synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁</p><h2 id="多个线程等待同一个snchronized锁的时候-jvm如何选择下一个获取锁的线程" tabindex="-1"><a class="header-anchor" href="#多个线程等待同一个snchronized锁的时候-jvm如何选择下一个获取锁的线程" aria-hidden="true">#</a> 多个线程等待同一个snchronized锁的时候，JVM如何选择下一个获取锁的线程?</h2><h2 id="synchronized使得同时只有一个线程可以执行-性能比较差-有什么提升的方法" tabindex="-1"><a class="header-anchor" href="#synchronized使得同时只有一个线程可以执行-性能比较差-有什么提升的方法" aria-hidden="true">#</a> Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?</h2><h2 id="我想更加灵活地控制锁的释放和获取-现在释放锁和获取锁的时机都被规定死了-怎么办" tabindex="-1"><a class="header-anchor" href="#我想更加灵活地控制锁的释放和获取-现在释放锁和获取锁的时机都被规定死了-怎么办" aria-hidden="true">#</a> 我想更加灵活地控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办?</h2><h2 id="什么是锁的升级和降级-什么是jvm里的偏斜锁、轻量级锁、重量级锁" tabindex="-1"><a class="header-anchor" href="#什么是锁的升级和降级-什么是jvm里的偏斜锁、轻量级锁、重量级锁" aria-hidden="true">#</a> 什么是锁的升级和降级? 什么是JVM里的偏斜锁、轻量级锁、重量级锁?</h2><h2 id="不同的jdk中对synchronized有何优化" tabindex="-1"><a class="header-anchor" href="#不同的jdk中对synchronized有何优化" aria-hidden="true">#</a> 不同的JDK中对Synchronized有何优化?</h2>',47),h={render:function(e,n){return r}}}}]);